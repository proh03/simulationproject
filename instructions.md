# simulationproject
Alright, for the read-me I am just copy-pasting the instructions for the assigment from the email. This way we can keep all the directions and stuff in one place.
Simulation Mini-Project

This assignment is due November 18 in class. Come prepared to demo your simulation project.

You assignment is to work in a group with two colleagues to design, implement, test, and demo a program that simulates and graphically animates of the simulation of an interesting dynamic system. You should start with the simple but fully working example that I provided in class. The  codeis here: https://piazza.com/class_profile/get_resource/idsstabhpmav3/igssqowf7ef1rm.

I provide the code to you as a "gzipped tar file." The "tar" program is a unix/linux-based program for wrapping a set of files into a single file for distribution. Gzip is a file compression program that packs a file down to a smaller size without losing any information. To create this archive file, I put all of the files for the demo system in a directory called simulation, and then, in the parent directory I issues the shell command "tar czf simulation.tar.gz simulation". The c option means create an archive file. The z option means "zip" the result.  The f option means that the name of the file to create follows. And the "simulation" is the name of the single file (which was actually a directory, including all of its contents) to copy into the archive file. From this archive file you can reconstitute the simulation file (directory and all contained files) by issuing the command "tar xzf simulation.tar.gz". The x command means extract the files from the archive; z means unzip the archive; and f again says that what follows is the name of the archive."

You are to coordinate development with your group using git and GitHub. You group should agree on a repo to use for this project. It should be separate from your personal, individual repos. It can however be created in just one of the group member's GitHub account. Whoever creates the repo will need to add the other group members as collaborators. To do this, the owner of the repo will need to know the GitHub account names of the other group members. A quick "Google" search will yield clear guidance on how to add collaborators to a repo. I trust that most of you can figure it out on your own, but if you get stuck, post to Piazza here for help.

Once you have a GitHub repo set up, one group member should download and unzip the archive file I've provided here, then do a "git init' in the resulting "simulation" directory, then use the notes you have on using github to set the remote repo to be your new github repo, and finally "push" the contents of the "simulation" directory to your GitHub repo. The other group members should then clone that repo onto their local machines/laptops. Now your group will be up and running. Try to get all of this set-up work done by Tuesday evening, November 10; it's crucial that your group get a very quick start on this project, otherwise you will quickly get behind. NOTE: Don't create your local "simulation" directory inside another directory that's already a git repo. You can tell if a directory is part of a git repo by doing "ls -la" and looking for a .git file. If there's no file, then the directory is not part of a git repo. A good place for this work might be in ~/my/stuff/cs1/simulation.

Once all members of your group have successfully cloned the group repo, then each person should make sure that the code runs. Do this by running the shell command "python catGo.py" from within the "simulation" directory. You should see the cat move across the screen.

Once you all have the code working, then you should carefully study the code. You won't fully understand and don't need to fully understand a few of the commands, namely those that make calls to procedures from the imported "pygame" module. Pygame is a framework for writing games and has been used to implement many successful computer games. Our simulation uses pygame, but you do not need to learn pygame to use this simulation "framework". Rather, I've set it up so that for the most part, you just write a few simple pieces of code: establish the initial state, write a state update function, write a termination predicate function, etc. The only places where you'll run into a few pygame issues is in the code to draw the state of your simulation and the code that you might write to handle mouse clicks and other user interaction events. We'll talk a little about these things on Wednesday Nov 11, this week.

Each group should select one person who will be a project coordinator, another who will serve as the lead developer, and a third who will be a lead tester. Everyone should understand and take part in all of these activities, but it can be helpful to have one person whose responsibility is to ensure that these things get done. A project manager organizes the processes that lead to agreement on what is to be built, and handles issues of coordination: when and where meetings will happen, who is working on what code, etc. A *crucial* job of the project manager is to coordinate changes to the code to avoid version control conflicts. A lead developer organizes group decision-making about how the code will be developed. The lead tester organizes efforts to test all code. Again, everyone should be involved in all of these activities.

GitHub provides a lot of support for collaboration. We recommend that you explore the "issue tracker' and consider using it. We also strongly recommend that you learn how to set up GitHub so that each group member is notified by email of each commit to the repo. Again, just Google it and follow the guidance that you will fine.

NOTE CAREFULLY: GitHub also makes your development activities visible and transparent. As instructors we WILL be able to see who committed to the GitHub repo, when, and exactly what was committed. If you wait until the last day or two to start working on this project, we will see that and will grade accordingly. As a good software practice, you should *only* commit changes that result in fully working code, *and* you should commit each such change. We are expecting to see a first commit -- of our demo code -- by the end of the day on Tuesday, and then consistent committing in the days to follow.

So how should you proceed? We recommend that you first fully understand how the demo system is working. Then try to make a single enhancement to validate your understanding of the code and your ability to make a coherent, consistent, meaningful change in its behavior. For example, instead of terminating when the cat reaches the right wall, perhaps you want to just have the cat bounce off the way. To implement this, you might first want to extend the cat state from a single x-coordinate to a tuple with an x-coordinate and a speed component expressed in pixels per clock tick. Setting the speed to 1 will make the cat move to the right one pixel per clock tick; setting it to -1 will make the cat move left; and setting it from 1 to -1 when the cat gets to the right side of the screen will make the cat bounce.

At this point you will clearly see how the system works. The next questions to answer are (1) what systems do *we* want to simulate; (2) how can we model its state; (3) what are the state update, termination, and display functions? These are the key questions. Note that you can simulate systems with multiple objects by representing the system state as, e.g., a iist of tuples, one for each object in the system. The state update function will be a little more complex, but the overall design remains the same.

We suggest that you interleave working on this simulation with watching and learning from the Python videos. You should work through them systematically, but you can also jump around if you feel the need to understand a particular mechanism for some part of your design.

You will be graded on having a working system that demonstrates mastery of the concepts along with *creativity* and evidence of an enthusiastic commitment of time and energy to this project. The grade on this project, as on the set homework, will be weighted significantly more heavily that the nightly homeworks. This is a mini-project, really, and will count as such. Each person in a group will receive the same grade. Each person will be required to pledge under honor committee rules to having contributed roughly equally to the work of the group. If a group has a member who is not cooperating, group members should contact the instructor for assistance.

If there's a strong consensus that a deadline extension from Wednesday to Friday is needed on this assignment, that will be possible, *however*, that must not be used as an excuse to delay working on this assignment. I will still require an in-class demonstration of the "almost finished" system on Wednesday, the original due date.

You've worked hard this semester. Now's a time to really start to have fun with your ability to program creatively. Do something interesting and impressive. Be responsible when it comes to pulling your weight. *Expect* to have some issues -- deciding what to do, scheduling time to talk, dealing with technology (such as git and GitHub as well as Python). That's just part of what it is to become a capable software developer.
